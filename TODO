2012-10-8

==> Implement new basic_block interface **DONE**
	--> Member functions **DONE**
	--> (un)conditional_jump **DONE**
	--> split **DONE**

==> Procedure extension with non-overlapping blocks **DONE**
	--> connect to unresolved ctrans edges **DONE**
	--> merge if new edges allow it **DONE**

==> Add way to find instructions of a mnemonic in a basic block **DONE**

==> Procedure refinement
	--> refine larger mnemonics with smaller
	--> split old block if inner mnemonics are target of ctrans **DONE**

==> memory support **DONE**
	--> memory value (zone name, endianess) **DONE**
	--> assignment class for instructions that specs slice of target (Bincoa) **DONE**
	--> code_generator.hh lvalue **DONE**
	--> avr.hh lvalue (var_decl in cg functions) **DONE**

==> replace width with slice in value, remove width from others **DONE**

==> remove implicit definitions of all varaibles **DONE**
	--> explicit initialization of UEVar's with ``undefinied'' **DONE**

==> code_generator
	--> test type inference **DONE**
	--> typechecks **DONE**
	--> fold superfluous IL
	--> ensure all value_ptr are only definied once **DONE**

==> Finish AVR disassembler
	--> compare into extra function **DONE**
	--> use constant instances w/ right width **DONE**
	--> missing instructions **INPROGRESS**

==> Data flow **DONE**
	--> Phi-node arguments w/ right widths **DONE**

==> include lib into gui **DONE**

==> Display analysis results in gui
	--> rvalue can be hovered/clicked/modifed **INPROGRESS: later**
	--> remove group_size from mnemonic::token, X/Y/Z are set in an ``internal'' mnemonic before st/ld **DONE**
	--> display sscp inline italic **DONE**

==> Improve edges  **DONE**
	--> space ctrans more than one connects a pair of bblocks **DONE**
	--> label ctrans with conditions **DONE**

==> Publish **DONE**
	--> bug when changing procedures **DONE**
	--> build system **DONE**

==> 0.9

==> Concurrentcy
	--> insert signals in Model **DONE**
	--> add signals for pending procs **DONE**
	--> defer gvLayout (layoutHierarchically/Custom), show spinner

==> Interactivity **DONE**
	--> share selection of proclist with flowview **DONE**
		--> tap "activate" signal from flowview **DONE**
	--> callback done/todo proc count **DONE**
	--> Proclist insert instead of clear **DONE**
	--> Enable CFG view **DONE**

==> Merge operation **DONE: [ABANDONED] Came up with a better algorithm**
	--> explode() function that splits a bb into single-mnemonic bb's
	--> simplify() function groups the the true bb's again
	--> merge() first calls explode on all bb's that are hit by ctrans, simplify is responsible of the callee 

==> Program points (Branch programpoint) **DONE: [POSTPONED] Merge when use case is clear**
	--> identify a single instr globally
	--> construct from bblock, mne_ptr, instr_ptr, proc or indices of mnemonic and instr
	--> argument to execute() and rewrite() (constructed on-the-fly)
	--> primary index in liveness, sat, cprop (more?)
	--> implement all comparison ops and std::hash
	--> string stream output
	--> not serialized

==> Datalog (Branch datalog) **DONE: [POSTPONED] Merge when use case is clear**
	--> support point and value
	--> implement liveness, dominance, dependency/taint and simple alias analysis

==> Finish new disassembly logic **DONE**
	--> disassemble_procedure **DONE**
	--> unit test **DONE**
	--> document **DONE**

==> Overall code improvements
	--> API documentation
	--> code review
	--> ditch assert() for exceptions
	--> move semantics for mnemonic, basic_block, value and guard
	--> ditch guard_ptr
	--> add value width to rdf
	--> unit tests for value
	--> doc
	--> proc::caller/callees weak proc ptr
	--> ctrans weak bblock ptrs

==> K-set domain for sparse constant propagation

==> Display Taint analysis/def-use chains

==> ``Range and Set Abstraction using SAT'' to improve guards

==> 1.0

==> File loader
	--> ELF
	--> PE
	--> more?

==> Hexview

==> Structs

==> Scripting
